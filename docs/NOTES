MORE ON PAIRED CACHES

Say we have a file cache with a l1 memory cache. Do a set with expires_variance. Both the caches should have the same expires and early expires time. And if possible, we should pick the same random # for them, so that they either both expire or both don't expire.

Also we have to make sure to override every external write API method in Paired.pm, because otherwise it will forward to the primary subcache and won't get applied to secondary. For example, multi_set() and expire().

Also make sure to handle get_object and set_object.

Paired.pm should in fact be a subclass of Driver, to handle some methods (e.g. is_valid, compute, get_multi_*, set_multi, expire) that layer on other driver methods by default.

REDOING MULTI-LEVEL CACHE API

Multilevel caches are a nice clean concept, but difficult to use and conceptualize in practice, especially when trying to add to an existing cache (very common).
* The multilevel driver doesn't know how to handle the methods of its parts, e.g. file or memcached specific methods
* The multilevel driver has a different ref() and driver() than the original, which can break existing code
* Hard to create specific multilevel behavior, e.g. level-one versus backup versus mirror-to caches.

So let's see if this API is better.

  my $cache = CHI->new(driver => 'Memcached',
                       servers => \@servers,
                       l1_cache => { driver => 'Memory', max_size => '10m' });

How does this cache handle...
- get, get_object: does a get on l1 first, returns if defined. Otherwise do a get on primary, and if defined, set in l1 with the same expiration time.
- set, set_object: sets the value in both
- remove, clear: calls on both
- get_keys, get_namespaces: calls on primary only, as l1 is presumed to have a subset of the keys in primary
- all other methods - call on primary as usual

  my $cache = CHI->new(driver => 'File',
                       root_dir => '/mnt/cache',
                       mirror_to_cache => { driver=>'File', root_dir=>'/mnt/cache.new');

How does this cache handle...
- set, set_object: sets the value in both
- remove, clear: calls on both
- get_keys, get_namespaces: calls on primary only, as mirror is presumed to be write-only
- all other methods - call on primary as usual

Now, it still might be cleaner to implement the new API using the multilevel driver in the background. That way we don't have to litter Driver.pm with a whole bunch of conditionals. Ideally, then, we'd delegate can() and isa() to the primary class.

In CHI.pm:
   if (my $sub_params = delete($params{l1_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params}, primary_index => 1);
   }
   if (my $sub_params = delete($params{mirror_to_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { \%params, $sub_params },
           primary_index=>0, no_distribute_reads = 1);  # or secondary_is_write_only, or only_primary_reads
   }

   # Maybe these later...
   if (my $sub_params = delete($params{backup_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params},
           primary_index=>0);
   }
   if (my $sub_params = delete($params{mirror_from_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params },
           primary_index=>1, no_secondary_writes = 1); # or secondary_is_read_only, or only_primary_reads
   }

where primary_index indicates which subcache the 'other' methods should be delegated to,
and the order of subcaches determines which subcache is read first.

In fact, Multilevel could implement some reasonable behavior (similar to what it does now), and then we could have Multilevel *subclasses* that implement l1, mirror, etc. Might be too much, but worth a try, instead of hardcoding a bunch of settings into Driver.pm.

Changes to Driver:
. Add chi_root_class, the factory class that created this driver (e.g. 'CHI'), so that
  it can be used to create other caches
. Add obj_ref to both get and set, if it exists it is populated with the cache object
. Add l1_cache and mirror_to_cache options

Paired:
. No longer a CHI::Driver subclass - delegates everything
. Add primary_index and primary_subcache
. Delegate can() and isa() to primary_subcache
. Add AUTOLOAD, can() and isa() that delegates to primary_subcache
* Test - similar to Multilevel, hopefully simpler
* Document
. Add disable_logging to Driver.pm, possibly make this the default for secondary caches (but useful nonetheless)

Other:
* Make l1_cache(), mirror_to_cache() options work as accessors

**Don't** try to make Paired a clean external API. Treat it like an internal class right
now, solely to support l1_cache and mirror_to_cache. Later, we can clean up the API, as well
as adding other aliases.

STORING META-INFORMATION

Need the ability to store meta-information about each namespace. Size is initial example,
but there might be others later, e.g. signature of structural params (like depth) to
signal when an object has been created with incompatible params.

First option is to store in keys, e.g. _CHI_RESERVED_SIZE.  Problem is that these get
reflected in get_keys. So we can wrap get_keys() just as we wrapped remove() and clear(),
call _get_keys() and then grep out _CHI_RESERVED keys.  But this now imposes a cost on
every get_keys call regardless of whether they are using metadata - the grep will copy the
entire list. (Though we can use a more efficient replacement algorithm -
~/perl/bench/listfilter.pl).

Another option is to store in a parallel namespace, e.g. _CHI_RESERVED. Several problems:
* How do we know the structural params (e.g. root_dir) to use when creating the cache for
this? We have to separate those out from the less crucial ones.
* Have to combine namespace and meta-key name in key.
* get_namespaces must be filtered instead of get_keys - perhaps not as big a deal
* Each cache object has to have a second cache object attached to it - have to memoize to avoid cost

SIZE AWARENESS

Behavior:
* If a cache is size aware, it keeps track of its own size. By default in key _CHI_RESERVED_SIZE.
* A cache is size aware if either is_size_aware or max_size are passed to the constructor.
* If a cache's size rises above its max_size, items are ejected until the cache size is
less than max_size x reduce_size_factor.
* Ejection is based on ejection_policy, which defaults to 'random'.

WRAPPING REMOVE, CLEAR

There is now a reason to wrap remove(), clear(), and get_keys() (size-aware support - see
above). We probably could have expected this to happen.

In general, should not require driver subclasses to respond directly to core public
methods: remove, clear, get_keys, get_namespaces. Instead, have them define the underline
versions: _remove, _clear etc. But underline versions are supposed to be for package-internal
methods - don't like to overload this standard. Also, where do we draw the line? Should
we likewise create an underscore version for get_namespaces, etc., on the assumption that
we'll need to wrap that too?

Could try to have CHI->new return a CHI object with a driver property, rather than
returning a driver directly, so that we can wrap calls to remove(), clear(), etc. CHI
object delegates everything to driver, including isa() and can(). But delegation is hard,
because Driver methods call other methods via $self - so $self would still have to be CHI
object - making inheritance not work right, etc. Remember the problems with Module::Pluggable.

Fortunately, any driver out there which defines remove(), etc., will still work - just
won't have size-aware support or whatever.

Another solution: Have CHI.pm use Sub::Prepend or similar on any driver class the first
time it is used. e.g. the first time someone says CHI->new(driver => 'File'), we wrap the
appropriate File methods. Driver subclass could optionally specify, via class data, which methods
not to wrap.

MASON INTEGRATION

Ideally we would incorporate the extra features from Mason's BaseCache such that we could
eliminate BaseCache and have $m->cache return a vanilla CHI handle.

Feature gap:
. expire method
. expire_if method (operating on metadata) (though this was never documented)
. get parameters, passed as hash after key
  . busy_lock - if object expires, set new expire time before returning undef
  . expire_if (NOT expires_if)
. cache object supports get_expires_at (NOT expires_at) as well as get_created_at

Some backward incompatibilities remain. People will have to change their
data_cache_defaults, as these will no longer make sense for CHI.  And any code that calls
obscure Cache::Cache methods on the result of $m->cache will fail.

Perhaps we use the old standby data_cache_api, which can now be one of '1.0',
'1.1', or 'chi'. In most cases '1.1' and 'chi' will be compatible.

In cache(), if data_cache_api = 'chi', then we use data_cache_defaults to create
and return a CHI handle. data_cache_defaults{'chi_root_class'} is used instead of
'CHI' if present; everything else is passed to CHI->new().

MULTILEVEL DRIVER

Actually multilevel is a bad name because of potential confusion with get_multi_*, set_multi, etc.

Other possible names: Composite, Chained

    my $cache = CHI->new(
        driver => 'Multilevel',
        subcaches => [
            { driver => 'Memory' },
            {
                driver  => 'Memcached',
                servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ]
            }
        ],
    );

get: do a get from each subcache in turn. on a hit from subcache N, write the value into
the subcache 0..N-1 (using the subcache's default set options). Then return the
value. Note that this means a set may occur into subcaches 0..N-1 with a later expire time
than subcache N.

get_object, get_expires_at: ugh...return the first one, I guess, and don't do any writing.

store: do a store to each cache (write-through).

delete, clear, get_keys, get_namespaces: do for each cache.

EXPIRES VARIANCE

For now, expires_variance must be specified as a floating point percentage. Can make more
flexible later, e.g. accept expires_variance a duration and/or percentage string, or
accept a two-element range for expires_in, accept an actual early_expires_in time.

System wide default expires_variance is 0.1.

After expires_at has been determined, compute early_expires_at. Store both in metadata.

On get, if time is between early_expires_at and expires_at, expire with probability
(time - early_expires_at) / (expires_at - early_expires_at).

SIMPLIFYING METADATA, SERIALIZE

To simplify the initial implementation I'm going to assume the default for use_metadata,
serialize and serializer. Not sure yet if any other settings would be useful.

METADATA

When use_metadata is true (by default), a small block of binary data is added to the end
of the value (after serialization, if any). We add to the end to reduce the effect on readability,
if this becomes a problem we can change it.

Currently it contains
* serialize type (4 bits)
* cache version (1 byte)
* expire time (4 bytes)
* length of metadata (1 byte) - must be last byte if metadata is at end

If use_metadata is false, no metadata is added, and we lose the following features:
* ability to get expire_time, and thus to use expires_window, for some backends (e.g. memcached)

SCALARS VERSUS STORABLE

serialize can be set to 'when-needed', 'always' or 'never'.

When set to 'when-needed' (the default), we serialize a value on set IF:
1) It is a reference, AND
2) The cache backend does not already auto-serialize (e.g. Cache::Cache)

On a get, we look at the metadata to determine whether to deserialize.

If use_metadata is false, then serialize will have to be set to 'always' or 'never'.

THE CHI API

use CHI;

my $cache = CHI->new(<driver>, { <options> });

Common options:
namespace           => undef
expires_in          => undef
expires_at          => undef
expires_window      => undef       ("1 minute", "20%")
max_items           => undef
on_set_error        => 'ignore'   ('ignore', 'warn', 'die', sub { })
serializer          => 'Storable' ('Storable', 'Data::Dumper', 'YAML::Syck')
should_serialize    => 'when-needed'  ('always', 'when-needed', 'never')
use_metadata        => 1

Set options:
expires_in     => undef
expires_at     => undef

my $cache = CHI->new({driver => 'Null'});
my $cache = CHI->new({driver => 'Memory' });
my $cache = CHI->new({driver => 'File', ..., cache_root => '/path/to/root' });
my $cache = CHI->new({driver => 'DBI', ..., dbh => $dbh or connect_options => [$data_source, $username, $auth, \%attr] });
my $cache = CHI->new({driver => 'CacheCache', ..., cache_class => 'File::Cache', cache_options => { ... } });
my $cache = CHI->new({driver => 'Memcached', ..., servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ], compress_threshold => 10_000});
my $cache = CHI->new({driver => 'FastMmap', ..., share_file => '/path/to/sharefile', cache_size => '1k' });

$cache->get($key);
$cache->set($key, $value, $expire_time | { options });
$cache->compute($key, sub { ... }, $expire_time | { options });
$cache->clear($key);
$cache->get_multi_arrayref([$key1, $key2, ...]);
$cache->get_multi_hashref([$key1, $key2, ...]);
$cache->set_multi({$key1 => $value1, $key2 => $value2, ...}, $expire_time | { options });
$cache->clear_multi([$key1, $key2, ...]);

my $meta = $cache->get_meta($key);
$meta->key();
$meta->expires_at();
$meta->serializer();
$meta->is_serialized();
$meta->cache_version();
