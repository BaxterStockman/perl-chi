SUBCACHE LOGGING

Say we have a File cache with a Memory L1 cache. How should hits, misses and sets on the L1 cache be logged?

Each could be logged on the l1 cache, on the parent cache, on the parent cache with special designations, or on both caches.

If we didn't do anything special, misses and sets would be logged on both caches, but hits would only be logged on the l1 cache - but we could fix that with an extra log line.

As long as the l1 cache has an appropriate description, mentioning the parent, then logging both would probably be the best. So we need to give people some control over description used in logs.

Right now, logs look like this:

    05/Mar/2009:00:02:44.35 cache get for namespace='/shared/findSite', key='domain=cosmopolitan.com', driver='File': HIT - www.cosmopolitan.com/sex-love/dating/Attract-Hot-Guys-Like-Crazy-3 - 16891-70
    05/Mar/2009:00:33:46.33 cache set for namespace='/shared/ams/getAmsPosCriteriaLOH', key='pos_id=252', size=16, expires='1h', time=0ms, driver='File' - www.esquire.com/ams/page-ads.js - 2052-38

Instead of driver='...', we could have cache='<desc>', where <desc> by default is the short driver name, but can be set to anything, e.g. 'file-local' or 'file-local@/foo/bar/baz'.

desc for an l1 or mirror_to cache can be <parent_desc>:l1 or <parent_desc>:mirror.

Errors look like this:

    error setting key 'foo' in CHI cache (driver=File, namespace=/bar/baz): ...

where "CHI cache (driver=File, namespace=/bar/baz)" is the description. This is only place that $self->desc() is used.

Would be nice to unify these. But "CHI cache" doesn't need to be in logs, and we want namespace to be easily separated out in logs.

Ok. Assuming that errors are being logged:

    05/Mar/2009:00:02:44.35 error during cache get for namespace='/shared/findSite', key='domain=cosmopolitan.com', cache='File': ...
    05/Mar/2009:00:02:44.35 cache get for namespace='/shared/findSite', key='domain=cosmopolitan.com', driver='File': HIT - www.cosmopolitan.com/sex-love/dating/Attract-Hot-Guys-Like-Crazy-3 - 16891-70

So now we have

    $self->_describe_cache_get($self, $key)
       => cache get for namespace='/shared/findSite', key='domain=cosmopolitan.com', cache='File'
    $self->_describe_cache_set($self, $key)
       => cache set for namespace='/shared/ams/getAmsPosCriteriaLOH', key='pos_id=252', size=16, expires='1h', cache='File'
that can be called for both logging and errors.


STAY WITH MOUSE FOR NOW?

What's the downside of sticking with Mouse for now? Basically, some people won't be able to do as much with introspection and possibly subclassing as they'd like.

Perhaps easiest to do this, and wait to see what happens with Any::Moose, performance of Moose itself, etc.

SWITCHING TO MOUSE/Any::Moose

Have gotten several comments about Moose being a heavy dependency on CHI. Realized that, with the limited feature set we use, we could get away with using Mouse and/or Any::Moose:, leaving the choice to the application of whether to incur Moose's cost.

Once Any::Moose makes a "choice" of which OO backer to use, it remains locked to that choice for the remainder of the application. e.g. if it chooses Mouse, it'll stay Mouse even if Moose is loaded later.

While I appreciate what Any::Moose is trying to do, the automatic backer selection is a little scary. If an application starts using a new module or changes the order of its 'use' statements, the selection of Moose vs Mouse can change silently for all Any::Moose-based modules. Any behavioral differences or bugs between the two will show up without apparent reason. This is classic action-at-a-distance. I suppose the same could be said for other 'Any' modules like YAML::Any and Config::Any (if you install a new YAML module, it might change the behavior of a YAML::Any-using application), but this one seems more critical than those. :) Anyway, installing a new version of a module can always affect existing applications - there's something especially insidious about effects from changing load order.

So in summary, I don't like the automatic backer selection, especially for something as large as CHI. I would prefer that the application pick the OO backer explicitly, defaulting to Mouse if no selection is made.

So suppose we have all drivers (and other Moose-using CHI classes) use

    use Any::Moose::Select;

which inherits from Any::Moose and overrides the following behaviors:

1) Any::Moose::Select maintains a single class property, backer(), which can be 'Mouse' or 'Moose', and defaults to 'Mouse'
2) You can set backer() by calling Any::Moose::Select->backer('Moose'), but this should die if has already been selected, either explicitly or implicitly
3) _backer_of is overriden to rely on backer()

PREPENDING SUBCLASS METHODS

Another, perhaps easier, way to transparently wrap driver methods. The first time a driver class (CHI::Driver::Memory) is used in CHI->new, create a dynamic subclass (CHI::Driver::Memory::AutoWrapped) that inherits from CHI::Driver::AutoWrap and CHI::Driver::Memory. AutoWrap.pm contains methods like

    sub remove {
        $self->call_native_driver('remove', @_);
        foreach my $cache ( @{ $self->{subcaches} } } ) {
            $self->remove(@_);
        }
    }
    
where

    sub call_native_driver {
        my $self = shift;
        my $method = shift;
        my $native_driver_class = $self->driver_class;
        my $native_driver_method = join("::", $native_driver_class, $method);
        $proto->$native_driver_method(@_);
    }

Document that driver_class is the way to get the true driver class, and that ref() no longer works.

PREPENDING DRIVER METHODS

Gotten to the point where there are multiple reasons to transparently wrap certain driver methods - e.g. remove(), clear(), get_keys(). Now needed at least for subcaches, size-awareness, and logging.

Proposal: Have CHI.pm use Sub::Prepend or similar on any driver class the first time it is used. e.g. the first time someone says CHI->new(driver => 'File'), we wrap the appropriate File methods. Driver subclass could optionally specify, via class data, which methods not to wrap.

Prepend methods are defined in Driver.pm as _pre_remove(), _pre_clear(), etc.

We could also ask driver subclass to manually call __PACKAGE__->register_driver_class or something at the bottom - might be a little better in terms of compilation order. Also, what happens if there is a mid-level virtual subclass, e.g. CHI::Driver::MyVirtualTypeOfDriver inherits from CHI::Driver? Then will definitely need to call __PACKAGE__->register_driver_class at the bottom.

What happens if we have a driver sub-sub-class, e.g. CHI::Driver::File::Fast which inherits from CHI::Driver::File, and has a remove() which calls SUPER::remove()? A call to remove will result in

   CHI::Driver::_pre_remove()
   CHI::Driver::File::Fast::remove()
   CHI::Driver::_pre_remove()
   CHI::Driver::File::remove()

To prevent this, _pre_* should set a dynamically scoped variable to $self. If it sees the flag set, it should skip the prepend code. There needs to be one dynamically scoped variable for each method - so use a hash.

PROBLEM WITH PAIRED CACHE IMPLEMENTATION: DELEGATION TRAP

Paired.pm has the same inherit problem as Module::Pluggable had - once you get "trapped" inside the primary cache class, methods will not be dispatched back to Paired.pm. No matter what mechinations we go through to keep things in Paired.pm.

e.g. Suppose that CHI::Driver::File has a get_politely() method, which essentially calls get() with some minor difference. get() will be called on the File class, not on Paired as it should be, and thus will circumvent the l1 cache.

So l1_cache and mirror_to_cache should be implemented in Driver.pm. However, we can still use our code to initialize those caches and inherit parameters from the primary.

Whoops! Another reason to override clear() and purge() in all drivers - we need to distribute to subcaches.

MORE ON PAIRED CACHES

Say we have a file cache with a l1 memory cache. Do a set with expires_variance. Both the caches should have the same expires and early expires time. And if possible, we should pick the same random # for them, so that they either both expire or both don't expire.

Also we have to make sure to override every external write API method in Paired.pm, because otherwise it will forward to the primary subcache and won't get applied to secondary. For example, multi_set() and expire().

Also make sure to handle get_object and set_object.

Paired.pm should in fact be a subclass of Driver, to handle some methods (e.g. is_valid, compute, get_multi_*) that are defined in terms of other driver methods by default.

Let's list out all the standard driver methods and make sure we know how to handle each one. For each, do we define specially or inherit from Driver.pm?

* fetch - inherit (acts on primary)
* store - inherit (acts on primary)
* remove - distribute to both
* get_keys - inherit (acts on primary)
* get_namespaces - inherit (acts on primary)
* get - define specially
* get_object - inherit (will call fetch, acts on primary)
* get_expires_at - inherit (will call get_object, acts on primary)
* exists_and_is_expired - inherit (will call get_object, acts on primary)
* is_valid - inherit (acts on primary)
* set - define specially
* expire - distribute to both
* expire_if - distribute to both
* compute - inherit (will call get and set)
* get_multi_arrayref - inherit (will call get)  ** should ideally define specially
* get_multi_array - inherit (will call get_multi_arrayref)
* get_multi_hashref - inherit (will call get_multi_arrayref)
* set_multi - inherit (will call set)  ** should ideally define specially
* remove_multi - inherit (will call remove)
* clear - distribute to both
* purge - distribute to both
* dump_as_hash - inherit (acts on primary)
* is_empty - inherit (will call get_keys, acts on primary)

define specially - get, set[, get_multi_arrayref]
distribute to both - remove, expire, expire_if, clear, purge
inherit - all others

REDOING MULTI-LEVEL CACHE API

Multilevel caches are a nice clean concept, but difficult to use and conceptualize in practice, especially when trying to add to an existing cache (very common).
* The multilevel driver doesn't know how to handle the methods of its parts, e.g. file or memcached specific methods
* The multilevel driver has a different ref() and driver() than the original, which can break existing code
* Hard to create specific multilevel behavior, e.g. level-one versus backup versus mirror-to caches.

So let's see if this API is better.

  my $cache = CHI->new(driver => 'Memcached',
                       servers => \@servers,
                       l1_cache => { driver => 'Memory', max_size => '10m' });

How does this cache handle...
- get, get_object: does a get on l1 first, returns if defined. Otherwise do a get on primary, and if defined, set in l1 with the same expiration time.
- set, set_object: sets the value in both
- remove, clear: calls on both
- get_keys, get_namespaces: calls on primary only, as l1 is presumed to have a subset of the keys in primary
- all other methods - call on primary as usual

  my $cache = CHI->new(driver => 'File',
                       root_dir => '/mnt/cache',
                       mirror_to_cache => { driver=>'File', root_dir=>'/mnt/cache.new');

How does this cache handle...
- set, set_object: sets the value in both
- remove, clear: calls on both
- get_keys, get_namespaces: calls on primary only, as mirror is presumed to be write-only
- all other methods - call on primary as usual

Now, it still might be cleaner to implement the new API using the multilevel driver in the background. That way we don't have to litter Driver.pm with a whole bunch of conditionals. Ideally, then, we'd delegate can() and isa() to the primary class.

In CHI.pm:
   if (my $sub_params = delete($params{l1_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params}, primary_index => 1);
   }
   if (my $sub_params = delete($params{mirror_to_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { \%params, $sub_params },
           primary_index=>0, no_distribute_reads = 1);  # or secondary_is_write_only, or only_primary_reads
   }

   # Maybe these later...
   if (my $sub_params = delete($params{backup_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params},
           primary_index=>0);
   }
   if (my $sub_params = delete($params{mirror_from_cache})) {
       return CHI::Driver::Paired->new
          (subcaches => { $sub_params, \%params },
           primary_index=>1, no_secondary_writes = 1); # or secondary_is_read_only, or only_primary_reads
   }

where primary_index indicates which subcache the 'other' methods should be delegated to,
and the order of subcaches determines which subcache is read first.

In fact, Multilevel could implement some reasonable behavior (similar to what it does now), and then we could have Multilevel *subclasses* that implement l1, mirror, etc. Might be too much, but worth a try, instead of hardcoding a bunch of settings into Driver.pm.

Changes to Driver:
. Add chi_root_class, the factory class that created this driver (e.g. 'CHI'), so that
  it can be used to create other caches
. Add obj_ref to both get and set, if it exists it is populated with the cache object
. Add l1_cache and mirror_to_cache options

Paired:
. No longer a CHI::Driver subclass - delegates everything
. Add primary_index and primary_subcache
. Delegate can() and isa() to primary_subcache
. Add AUTOLOAD, can() and isa() that delegates to primary_subcache
* Test - similar to Multilevel, hopefully simpler
* Document
. Add disable_logging to Driver.pm, possibly make this the default for secondary caches (but useful nonetheless)

Other:
* Make l1_cache(), mirror_to_cache() options work as accessors

**Don't** try to make Paired a clean external API. Treat it like an internal class right
now, solely to support l1_cache and mirror_to_cache. Later, we can clean up the API, as well
as adding other aliases.

STORING META-INFORMATION

Need the ability to store meta-information about each namespace. Size is initial example,
but there might be others later, e.g. signature of structural params (like depth) to
signal when an object has been created with incompatible params.

First option is to store in keys, e.g. _CHI_RESERVED_SIZE.  Problem is that these get
reflected in get_keys. So we can wrap get_keys() just as we wrapped remove() and clear(),
call _get_keys() and then grep out _CHI_RESERVED keys.  But this now imposes a cost on
every get_keys call regardless of whether they are using metadata - the grep will copy the
entire list. (Though we can use a more efficient replacement algorithm -
~/perl/bench/listfilter.pl).

Another option is to store in a parallel namespace, e.g. _CHI_RESERVED. Several problems:
* How do we know the structural params (e.g. root_dir) to use when creating the cache for
this? We have to separate those out from the less crucial ones.
* Have to combine namespace and meta-key name in key.
* get_namespaces must be filtered instead of get_keys - perhaps not as big a deal
* Each cache object has to have a second cache object attached to it - have to memoize to avoid cost

SIZE AWARENESS

Behavior:
* If a cache is size aware, it keeps track of its own size. By default in key _CHI_RESERVED_SIZE.
* A cache is size aware if either is_size_aware or max_size are passed to the constructor.
* If a cache's size rises above its max_size, items are ejected until the cache size is
less than max_size x reduce_size_factor.
* Ejection is based on ejection_policy, which defaults to 'random'.

WRAPPING REMOVE, CLEAR

There is now a reason to wrap remove(), clear(), and get_keys() (size-aware support - see
above). We probably could have expected this to happen.

In general, should not require driver subclasses to respond directly to core public
methods: remove, clear, get_keys, get_namespaces. Instead, have them define the underline
versions: _remove, _clear etc. But underline versions are supposed to be for package-internal
methods - don't like to overload this standard. Also, where do we draw the line? Should
we likewise create an underscore version for get_namespaces, etc., on the assumption that
we'll need to wrap that too?

Could try to have CHI->new return a CHI object with a driver property, rather than
returning a driver directly, so that we can wrap calls to remove(), clear(), etc. CHI
object delegates everything to driver, including isa() and can(). But delegation is hard,
because Driver methods call other methods via $self - so $self would still have to be CHI
object - making inheritance not work right, etc. Remember the problems with Module::Pluggable.

Fortunately, any driver out there which defines remove(), etc., will still work - just
won't have size-aware support or whatever.

Another solution: Have CHI.pm use Sub::Prepend or similar on any driver class the first
time it is used. e.g. the first time someone says CHI->new(driver => 'File'), we wrap the
appropriate File methods. Driver subclass could optionally specify, via class data, which methods
not to wrap.

MASON INTEGRATION

Ideally we would incorporate the extra features from Mason's BaseCache such that we could
eliminate BaseCache and have $m->cache return a vanilla CHI handle.

Feature gap:
. expire method
. expire_if method (operating on metadata) (though this was never documented)
. get parameters, passed as hash after key
  . busy_lock - if object expires, set new expire time before returning undef
  . expire_if (NOT expires_if)
. cache object supports get_expires_at (NOT expires_at) as well as get_created_at

Some backward incompatibilities remain. People will have to change their
data_cache_defaults, as these will no longer make sense for CHI.  And any code that calls
obscure Cache::Cache methods on the result of $m->cache will fail.

Perhaps we use the old standby data_cache_api, which can now be one of '1.0',
'1.1', or 'chi'. In most cases '1.1' and 'chi' will be compatible.

In cache(), if data_cache_api = 'chi', then we use data_cache_defaults to create
and return a CHI handle. data_cache_defaults{'chi_root_class'} is used instead of
'CHI' if present; everything else is passed to CHI->new().

MULTILEVEL DRIVER

Actually multilevel is a bad name because of potential confusion with get_multi_*, set_multi, etc.

Other possible names: Composite, Chained

    my $cache = CHI->new(
        driver => 'Multilevel',
        subcaches => [
            { driver => 'Memory' },
            {
                driver  => 'Memcached',
                servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ]
            }
        ],
    );

get: do a get from each subcache in turn. on a hit from subcache N, write the value into
the subcache 0..N-1 (using the subcache's default set options). Then return the
value. Note that this means a set may occur into subcaches 0..N-1 with a later expire time
than subcache N.

get_object, get_expires_at: ugh...return the first one, I guess, and don't do any writing.

store: do a store to each cache (write-through).

delete, clear, get_keys, get_namespaces: do for each cache.

EXPIRES VARIANCE

For now, expires_variance must be specified as a floating point percentage. Can make more
flexible later, e.g. accept expires_variance a duration and/or percentage string, or
accept a two-element range for expires_in, accept an actual early_expires_in time.

System wide default expires_variance is 0.1.

After expires_at has been determined, compute early_expires_at. Store both in metadata.

On get, if time is between early_expires_at and expires_at, expire with probability
(time - early_expires_at) / (expires_at - early_expires_at).

SIMPLIFYING METADATA, SERIALIZE

To simplify the initial implementation I'm going to assume the default for use_metadata,
serialize and serializer. Not sure yet if any other settings would be useful.

METADATA

When use_metadata is true (by default), a small block of binary data is added to the end
of the value (after serialization, if any). We add to the end to reduce the effect on readability,
if this becomes a problem we can change it.

Currently it contains
* serialize type (4 bits)
* cache version (1 byte)
* expire time (4 bytes)
* length of metadata (1 byte) - must be last byte if metadata is at end

If use_metadata is false, no metadata is added, and we lose the following features:
* ability to get expire_time, and thus to use expires_window, for some backends (e.g. memcached)

SCALARS VERSUS STORABLE

serialize can be set to 'when-needed', 'always' or 'never'.

When set to 'when-needed' (the default), we serialize a value on set IF:
1) It is a reference, AND
2) The cache backend does not already auto-serialize (e.g. Cache::Cache)

On a get, we look at the metadata to determine whether to deserialize.

If use_metadata is false, then serialize will have to be set to 'always' or 'never'.

THE CHI API

use CHI;

my $cache = CHI->new(<driver>, { <options> });

Common options:
namespace           => undef
expires_in          => undef
expires_at          => undef
expires_window      => undef       ("1 minute", "20%")
max_items           => undef
on_set_error        => 'ignore'   ('ignore', 'warn', 'die', sub { })
serializer          => 'Storable' ('Storable', 'Data::Dumper', 'YAML::Syck')
should_serialize    => 'when-needed'  ('always', 'when-needed', 'never')
use_metadata        => 1

Set options:
expires_in     => undef
expires_at     => undef

my $cache = CHI->new({driver => 'Null'});
my $cache = CHI->new({driver => 'Memory' });
my $cache = CHI->new({driver => 'File', ..., cache_root => '/path/to/root' });
my $cache = CHI->new({driver => 'DBI', ..., dbh => $dbh or connect_options => [$data_source, $username, $auth, \%attr] });
my $cache = CHI->new({driver => 'CacheCache', ..., cache_class => 'File::Cache', cache_options => { ... } });
my $cache = CHI->new({driver => 'Memcached', ..., servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ], compress_threshold => 10_000});
my $cache = CHI->new({driver => 'FastMmap', ..., share_file => '/path/to/sharefile', cache_size => '1k' });

$cache->get($key);
$cache->set($key, $value, $expire_time | { options });
$cache->compute($key, sub { ... }, $expire_time | { options });
$cache->clear($key);
$cache->get_multi_arrayref([$key1, $key2, ...]);
$cache->get_multi_hashref([$key1, $key2, ...]);
$cache->set_multi({$key1 => $value1, $key2 => $value2, ...}, $expire_time | { options });
$cache->clear_multi([$key1, $key2, ...]);

my $meta = $cache->get_meta($key);
$meta->key();
$meta->expires_at();
$meta->serializer();
$meta->is_serialized();
$meta->cache_version();
