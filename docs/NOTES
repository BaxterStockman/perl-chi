STORING META-INFORMATION

Need the ability to store meta-information about each namespace. Size is initial example,
but there might be others later, e.g. signature of structural params (like depth) to
signal when an object has been created with incompatible params.

First option is to store in keys, e.g. _CHI_RESERVED_SIZE and _CHI_RESERVED_PARAMS.
Problem is that these get reflected in get_keys. So we can wrap get_keys() just as we
wrapped remove() and clear(), call _get_keys() and then grep out _CHI_RESERVED keys.
But this now imposes a cost on every get_keys call regardless of whether they are
using metadata - the grep will copy the entire list.

Another option is to store in a parallel namespace, e.g. _CHI_RESERVED. Several problems:
* How do we know the structural params (e.g. root_dir) to use when creating the cache for
this? We have to separate those out from the less crucial ones.
* Have to combine namespace and meta-key name in key.
* get_namespaces must be filtered, though not as big a deal.

Given the very small number of metadata keys (1 or 2, at least initially), and given that
get_keys is arbitrary order, could we use a more efficient filtering algorithm than grep?
Replace each found metadata key with the final key? Will this even matter?
- Benchmarked - ~/perl/bench/listfilter.pl - replace algorithm about three times faster
than grep.

But don't prematurely optimize. USE GREP FIRST and make a note to optimize later!

SIZE AWARENESS

Behavior:
* If a cache is size aware, it keeps track of its own size. By default in key _CHI_RESERVED_SIZE.
* A cache is size aware if either is_size_aware or max_size are passed to the constructor.
* If a cache's size rises above its max_size, items are ejected until the cache size is
less than max_size x reduce_size_factor.
* Ejection is based on ejection_policy, which defaults to 'random'.

WRAPPING REMOVE, CLEAR

There is now a reason to wrap remove() and clear() (size-aware support). We should have
known this would happen. In general, should not require driver subclasses to respond
directly to core public methods: remove, clear, get_keys, get_namespaces. Instead, have
them define the underline versions: _remove, _clear etc.

Could try to have CHI->new return a CHI object with a driver property, rather than
returning a driver directly, so that we can wrap calls to remove(), clear(), etc. CHI
object delegates everything to driver, including isa() and can(). But delegation is hard,
because Driver methods call other methods via $self - so $self would still have to be CHI
object - making inheritance not work right, etc. Remember the problems with Module::Pluggable.

Fortunately, any driver out there which defines remove(), etc., will still work - just
won't have size-aware support or whatever.

MASON INTEGRATION

Ideally we would incorporate the extra features from Mason's BaseCache such that we could eliminate
BaseCache and have $m->cache return a vanilla CHI handle.

Feature gap:
. expire method
. expire_if method (operating on metadata) (though this was never documented)
. get parameters, passed as hash after key
  . busy_lock - if object expires, set new expire time before returning undef
  . expire_if (NOT expires_if)
. cache object supports get_expires_at (NOT expires_at) as well as get_created_at

Some backward incompatibilities remain. People will have to change their
data_cache_defaults, as these will no longer make sense for CHI.  And any code that calls
obscure Cache::Cache methods on the result of $m->cache will fail.

Perhaps we use the old standby data_cache_api, which can now be one of '1.0',
'1.1', or 'chi'. In most cases '1.1' and 'chi' will be compatible.

In cache(), if data_cache_api = 'chi', then we use data_cache_defaults to create
and return a CHI handle. data_cache_defaults{'chi_root_class'} is used instead of
'CHI' if present; everything else is passed to CHI->new().

MULTILEVEL DRIVER

Actually multilevel is a bad name because of potential confusion with get_multi_*, set_multi, etc.

Other possible names: Composite, Chained

    my $cache = CHI->new(
        driver => 'Multilevel',
        subcaches => [
            { driver => 'Memory' },
            {
                driver  => 'Memcached',
                servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ]
            }
        ],
    );

get: do a get from each subcache in turn. on a hit from subcache N, write the value into the subcache 0..N-1 (using the subcache's default set options). Then return the value. Note that this means a set may occur into subcaches 0..N-1 with a later expire time than subcache N.

get_object, get_expires_at: ugh...return the first one, I guess, and don't do any writing.

store: do a store to each cache (write-through).

delete, clear, get_keys, get_namespaces: do for each cache.

EXPIRES VARIANCE

For now, expires_variance must be specified as a floating point percentage. Can make more
flexible later, e.g. accept expires_variance a duration and/or percentage string, or
accept a two-element range for expires_in, accept an actual early_expires_in time.

System wide default expires_variance is 0.1.

After expires_at has been determined, compute early_expires_at. Store both in metadata.

On get, if time is between early_expires_at and expires_at, expire with probability
(time - early_expires_at) / (expires_at - early_expires_at).

SIMPLIFYING METADATA, SERIALIZE

To simplify the initial implementation I'm going to assume the default for use_metadata,
serialize and serializer. Not sure yet if any other settings would be useful.

METADATA

When use_metadata is true (by default), a small block of binary data is added to the end
of the value (after serialization, if any). We add to the end to reduce the effect on readability,
if this becomes a problem we can change it.

Currently it contains
* serialize type (4 bits)
* cache version (1 byte)
* expire time (4 bytes)
* length of metadata (1 byte) - must be last byte if metadata is at end

If use_metadata is false, no metadata is added, and we lose the following features:
* ability to get expire_time, and thus to use expires_window, for some backends (e.g. memcached)

SCALARS VERSUS STORABLE

serialize can be set to 'when-needed', 'always' or 'never'.

When set to 'when-needed' (the default), we serialize a value on set IF:
1) It is a reference, AND
2) The cache backend does not already auto-serialize (e.g. Cache::Cache)

On a get, we look at the metadata to determine whether to deserialize.

If use_metadata is false, then serialize will have to be set to 'always' or 'never'.

THE CHI API

use CHI;

my $cache = CHI->new(<driver>, { <options> });

Common options:
namespace           => undef
expires_in          => undef
expires_at          => undef
expires_window      => undef       ("1 minute", "20%")
max_items           => undef
on_set_error        => 'ignore'   ('ignore', 'warn', 'die', sub { })
serializer          => 'Storable' ('Storable', 'Data::Dumper', 'YAML::Syck')
should_serialize    => 'when-needed'  ('always', 'when-needed', 'never')
use_metadata        => 1

Set options:
expires_in     => undef
expires_at     => undef

my $cache = CHI->new({driver => 'Null'});
my $cache = CHI->new({driver => 'Memory' });
my $cache = CHI->new({driver => 'File', ..., cache_root => '/path/to/root' });
my $cache = CHI->new({driver => 'DBI', ..., dbh => $dbh or connect_options => [$data_source, $username, $auth, \%attr] });
my $cache = CHI->new({driver => 'CacheCache', ..., cache_class => 'File::Cache', cache_options => { ... } });
my $cache = CHI->new({driver => 'Memcached', ..., servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ], compress_threshold => 10_000});
my $cache = CHI->new({driver => 'FastMmap', ..., share_file => '/path/to/sharefile', cache_size => '1k' });

$cache->get($key);
$cache->set($key, $value, $expire_time | { options });
$cache->compute($key, sub { ... }, $expire_time | { options });
$cache->clear($key);
$cache->get_multi_arrayref([$key1, $key2, ...]);
$cache->get_multi_hashref([$key1, $key2, ...]);
$cache->set_multi({$key1 => $value1, $key2 => $value2, ...}, $expire_time | { options });
$cache->clear_multi([$key1, $key2, ...]);

my $meta = $cache->get_meta($key);
$meta->key();
$meta->expires_at();
$meta->serializer();
$meta->is_serialized();
$meta->cache_version();
